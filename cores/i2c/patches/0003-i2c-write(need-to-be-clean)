diff -Naur i2c/i2c_master_bit_ctrl.v i2c_escreve/i2c_master_bit_ctrl.v
--- i2c/i2c_master_bit_ctrl.v	2013-12-06 19:08:46.848143980 +0000
+++ i2c_escreve/i2c_master_bit_ctrl.v	2013-12-06 17:59:57.729258319 +0000
@@ -139,6 +139,7 @@
 // synopsys translate_on
 
 `include "i2c_master_defines.v"
+`define test
 
 module i2c_master_bit_ctrl (
     input             clk,      // system clock
@@ -169,7 +170,9 @@
     output reg        cmd_slave_ack,
     input [1:0]       slave_cmd ,
     input             sl_wait,
-    output            slave_reset
+    output            slave_reset,
+    output	      recev_ack,  //slave ack
+    output	      sto_condition  //stop signal
 
 );
 
@@ -280,8 +283,8 @@
       end
       else if (~|filter_cnt)
       begin
-          fSCL <= {fSCL[1:0],cSCL[1]};
-          fSDA <= {fSDA[1:0],cSDA[1]};
+          fSCL <= {fSCL[1:0],scl_i};  //fSCL <= {fSCL[1:0],cSCL[1]};
+          fSDA <= {fSDA[1:0],sda_i};  //fSDA <= {fSDA[1:0],cSDA[1]};
       end
 
 
@@ -328,7 +331,7 @@
           sta_condition <= 1'b0;
           sto_condition <= 1'b0;
       end
-      else
+      else if (~master_mode)
       begin
           sta_condition <= ~sSDA &  dSDA & sSCL;
           sto_condition <=  sSDA & ~dSDA & sSCL;
@@ -366,13 +369,23 @@
 
     // generate dout signal (store SDA on rising edge of SCL)
     always @(posedge clk)
-      if (sSCL & ~dSCL) dout <= sSDA;
+     dout <= dSDA;// if (sSCL & ~dSCL) dout <= sSDA;
 
 
     // generate statemachine
 
     // nxt_state decoder
     parameter [17:0] idle    = 18'b0_0000_0000_0000_0000;
+`ifdef test
+    parameter [17:0] idle_a  = 18'b1_0000_0000_0000_0001;
+    parameter [17:0] idle_b  = 18'b1_0000_0000_0000_0010;
+    parameter [17:0] idle_c  = 18'b1_0000_0000_0000_0100;
+    parameter [17:0] idle_d  = 18'b1_0000_0000_0000_1000;
+    parameter [17:0] ack_a   = 18'b1_1111_1111_1111_0000;
+    parameter [17:0] ack_b   = 18'b1_1111_1111_1111_0001;
+    parameter [17:0] ack_c   = 18'b1_1111_1111_1111_0010;
+    parameter [17:0] ack_d   = 18'b1_1111_1111_1111_0100;
+`endif
     parameter [17:0] start_a = 18'b0_0000_0000_0000_0001;
     parameter [17:0] start_b = 18'b0_0000_0000_0000_0010;
     parameter [17:0] start_c = 18'b0_0000_0000_0000_0100;
@@ -391,6 +404,9 @@
     parameter [17:0] wr_c    = 18'b0_1000_0000_0000_0000;
     parameter [17:0] wr_d    = 18'b1_0000_0000_0000_0000;
 
+    parameter [17:0] wr_ab  =  18'b0_0110_0000_0000_0000;
+
+
     reg scl_oen_master ;
     reg sda_oen_master ;
     reg sda_oen_slave;
@@ -404,6 +420,7 @@
           scl_oen_master <=  1'b1;
           sda_oen_master <=  1'b1;
           sda_chk <= 1'b0;
+	  recev_ack <= 1'b0;
       end
       else if (rst | al)
       begin
@@ -412,6 +429,7 @@
           scl_oen_master <=  1'b1;
           sda_oen_master <=  1'b1;
           sda_chk <= 1'b0;
+	  recev_ack <= 1'b0;
       end
       else
       begin
@@ -427,18 +445,92 @@
                              `I2C_CMD_STOP:  c_state <= stop_a;
                              `I2C_CMD_WRITE: c_state <= wr_a;
                              `I2C_CMD_READ:  c_state <= rd_a;
+
+`ifndef test
                              default:        c_state <= idle;
+`endif
+`ifdef test
+			     `I2C_CMD_S_ACK: c_state <= ack_a;
+			     default: 	     c_state <= idle;
+`endif
                         endcase
 
                         scl_oen_master <= scl_oen_master; // keep SCL in same state
                         sda_oen_master <= sda_oen_master; // keep SDA in same state
                         sda_chk <= 1'b0;    // don't check SDA output
                     end
+`ifdef test
+                    ack_a:
+                    begin
+                        c_state <= ack_b;
+                        scl_oen_master <= 1'b0; // keep SCL low
+                        sda_oen_master <= 1'b1; // tri-state SDA
+
+                    end
+
+                    ack_b:
+                    begin
+                        c_state <= ack_c;
+			    if(~sda_i )//(~sda_i & ~sSDA)
+			    begin
+				//c_state <= idle;
+				recev_ack <= 1'b1;
+			    end
+                        cmd_ack <= 1'b1;
+                        scl_oen_master <= 1'b1; // set SCL high
+                        sda_oen_master <= 1'b1; // keep SDA tri-stated
+                        sda_chk <= 1'b0; // don't check SDA output
+                    end
+
+                    ack_c:
+                    begin
+                        c_state <= ack_d;
+                        scl_oen_master <= 1'b1; // keep SCL high
+                        sda_oen_master <= 1'b1; // keep SDA tri-stated
+                        sda_chk <= 1'b0; // don't check SDA output
+                    end
+
+                    ack_d:
+                    begin
+                        c_state <= idle;
+                        scl_oen_master <= 1'b0; // set SCL low
+                        sda_oen_master <= 1'b1; // keep SDA tri-stated
+                        sda_chk <= 1'b0; // don't check SDA output
+                    end
+
+
+                    idle_a:
+                    begin
+                        c_state <= idle_b;
+                        scl_oen_master <= 1'b0; // keep SCL in same state
+                    end
+
+                    idle_b:
+                    begin
+                        c_state <= idle_c;
+                        scl_oen_master <= 1'b1; // set SCL high
+                    end
+
+                    idle_c:
+                    begin
+                        c_state <= idle_d;
+                        scl_oen_master <= 1'b1; // keep SCL high
+                    end
+
+                    idle_d:
+                    begin
+                        c_state <= idle;
+                        scl_oen_master <= 1'b0; // keep SCL high
+                    end
+`endif
+
+
 
                     // start
                     start_a:
                     begin
                         c_state <= start_b;
+	  		recev_ack <= 1'b0;
                         scl_oen_master <= scl_oen_master; // keep SCL in same state
                         sda_oen_master <= 1'b1;    // set SDA high
                         sda_chk <= 1'b0;    // don't check SDA output
@@ -455,6 +547,7 @@
                     start_c:
                     begin
                         c_state <= start_d;
+                        cmd_ack <= 1'b1;
                         scl_oen_master <= 1'b1; // keep SCL high
                         sda_oen_master <= 1'b0; // set SDA low
                         sda_chk <= 1'b0; // don't check SDA output
@@ -471,7 +564,6 @@
                     start_e:
                     begin
                         c_state <= idle;
-                        cmd_ack <= 1'b1;
                         scl_oen_master <= 1'b0; // set SCL low
                         sda_oen_master <= 1'b0; // keep SDA low
                         sda_chk <= 1'b0; // don't check SDA output
@@ -481,6 +573,7 @@
                     stop_a:
                     begin
                         c_state <= stop_b;
+	  		recev_ack <= 1'b0;
                         scl_oen_master <= 1'b0; // keep SCL low
                         sda_oen_master <= 1'b0; // set SDA low
                         sda_chk <= 1'b0; // don't check SDA output
@@ -489,6 +582,7 @@
                     stop_b:
                     begin
                         c_state <= stop_c;
+                        cmd_ack <= 1'b1;
                         scl_oen_master <= 1'b1; // set SCL high
                         sda_oen_master <= 1'b0; // keep SDA low
                         sda_chk <= 1'b0; // don't check SDA output
@@ -505,7 +599,6 @@
                     stop_d:
                     begin
                         c_state <= idle;
-                        cmd_ack <= 1'b1;
                         scl_oen_master <= 1'b1; // keep SCL high
                         sda_oen_master <= 1'b1; // set SDA high
                         sda_chk <= 1'b0; // don't check SDA output
@@ -515,6 +608,7 @@
                     rd_a:
                     begin
                         c_state <= rd_b;
+	  		recev_ack <= 1'b0;
                         scl_oen_master <= 1'b0; // keep SCL low
                         sda_oen_master <= 1'b1; // tri-state SDA
                         sda_chk <= 1'b0; // don't check SDA output
@@ -523,6 +617,7 @@
                     rd_b:
                     begin
                         c_state <= rd_c;
+                        cmd_ack <= 1'b1;
                         scl_oen_master <= 1'b1; // set SCL high
                         sda_oen_master <= 1'b1; // keep SDA tri-stated
                         sda_chk <= 1'b0; // don't check SDA output
@@ -539,7 +634,7 @@
                     rd_d:
                     begin
                         c_state <= idle;
-                        cmd_ack <= 1'b1;
+
                         scl_oen_master <= 1'b0; // set SCL low
                         sda_oen_master <= 1'b1; // keep SDA tri-stated
                         sda_chk <= 1'b0; // don't check SDA output
@@ -548,7 +643,17 @@
                     // write
                     wr_a:
                     begin
+                        c_state <= wr_ab;
+	  		recev_ack <= 1'b0;
+                        scl_oen_master <= 1'b0; // keep SCL low
+                        sda_oen_master <= sda_oen_master;  // set SDA
+                        sda_chk <= 1'b0; // don't check SDA output (SCL low)
+                    end
+
+                    wr_ab:
+                    begin
                         c_state <= wr_b;
+	  		recev_ack <= 1'b0;
                         scl_oen_master <= 1'b0; // keep SCL low
                         sda_oen_master <= din;  // set SDA
                         sda_chk <= 1'b0; // don't check SDA output (SCL low)
@@ -557,8 +662,9 @@
                     wr_b:
                     begin
                         c_state <= wr_c;
+                        cmd_ack <= 1'b1;
                         scl_oen_master <= 1'b1; // set SCL high
-                        sda_oen_master <= din;  // keep SDA
+                        sda_oen_master <= sda_oen_master;  // keep SDA
                         sda_chk <= 1'b0; // don't check SDA output yet
                                             // allow some time for SDA and SCL to settle
                     end
@@ -567,16 +673,15 @@
                     begin
                         c_state <= wr_d;
                         scl_oen_master <= 1'b1; // keep SCL high
-                        sda_oen_master <= din;
-                        sda_chk <= 1'b1; // check SDA output
+                        sda_oen_master <= sda_oen_master;
+                        sda_chk <= 1'b0; // check SDA output
                     end
 
                     wr_d:
                     begin
                         c_state <= idle;
-                        cmd_ack <= 1'b1;
                         scl_oen_master <= 1'b0; // set SCL low
-                        sda_oen_master <= din;
+                        sda_oen_master <= sda_oen_master;
                         sda_chk <= 1'b0; // don't check SDA output (SCL low)
                     end
 
@@ -641,14 +746,14 @@
        begin
           slave_state <=  slave_idle;
           cmd_slave_ack   <=  1'b0;
-          sda_oen_slave   <=  1'b1;
+          sda_oen_slave   <=  1'b0;
           scl_oen_slave   <=  1'b1;
        end
-     else if (rst | sta_condition || !ena)
+     else if (rst | sta_condition)//(rst | sta_condition || !ena)
        begin
           slave_state <=  slave_idle;
           cmd_slave_ack   <=  1'b0;
-          sda_oen_slave   <=  1'b1;
+          //sda_oen_slave   <=  1'b0;
           scl_oen_slave   <=  1'b1;
        end
      else
@@ -667,7 +772,7 @@
 
                  case (slave_cmd) // synopsys full_case parallel_case
                    `I2C_SLAVE_CMD_WRITE: slave_state <=  slave_wr;
-                   `I2C_SLAVE_CMD_READ:
+                   `I2C_SLAVE_CMD_READ:	
 		     begin
 			slave_state <=  slave_rd;
 			// Restore SDA high here in case we're got it low
@@ -706,17 +811,18 @@
 
             slave_rd:
               begin
-                 if (sSCL & ~dSCL)  begin   // SCL Rising edge
+                 if (~sSCL & dSCL)  begin   // SCL Rising edge
                     slave_state <=  slave_rd_a;
+		    //dout <= sda_i;
                  end
               end
 
             slave_rd_a:
               begin
-                 if (~sSCL & dSCL)  begin       // SCL falling edge
+                 //if (sSCL & ~dSCL)  begin       // SCL falling edge
                     cmd_slave_ack <=  1'b1;
                     slave_state <=  slave_wait_next_cmd_1;
-                 end
+                 //end
               end
           endcase // case (slave_state)
        end
diff -Naur i2c/i2c_master_byte_ctrl.v i2c_escreve/i2c_master_byte_ctrl.v
--- i2c/i2c_master_byte_ctrl.v	2013-12-06 19:08:46.848143980 +0000
+++ i2c_escreve/i2c_master_byte_ctrl.v	2013-12-06 18:06:04.768644010 +0000
@@ -77,8 +77,7 @@
    clk, my_addr, rst, nReset, ena, clk_cnt, start, stop, read, write, ack_in,
    din, cmd_ack, ack_out, dout, i2c_busy, i2c_al, scl_i, sl_cont, scl_o,
    scl_oen, sda_i, sda_o, sda_oen,slave_dat_req, slave_en, slave_dat_avail,
-   slave_act, slave_cmd_ack
-   );
+   slave_act, slave_cmd_ack, stop_signal);
 
 
 	//
@@ -121,6 +120,8 @@
     output reg 	slave_dat_avail;
     output reg 	slave_act;
     output reg 	slave_cmd_ack;
+
+	output stop_signal; //stop signal
 	//
 	// Variable declarations
 	//
@@ -194,7 +195,9 @@
 		.cmd_slave_ack (slave_ack),
 		.slave_cmd (slave_cmd_out),
 		.sl_wait (sl_wait),
-		.slave_reset (slave_reset)
+		.slave_reset (slave_reset),
+		.recev_ack(receved_ask),
+		.sto_condition(stop_signal)
 	);
 
 	reg 		slave_adr_received_d;
@@ -274,7 +277,7 @@
 	       cmd_ack  <= 1'b0;
 	       c_state  <= ST_IDLE;
 	       ack_out  <= 1'b0;
-	       master_mode <=  1'b0;
+	       //master_mode <=  1'b0;
 	       slave_cmd  <=  2'b0;
 	       slave_cmd_out <=  2'b0;
 	       slave_dat_req	<=  1'b0;
@@ -296,16 +299,16 @@
 	        ST_IDLE:
 			  begin
 			     slave_act <=  1'b0;
-			     if (slave_en & slave_adr_received &
-				 (slave_adr[7:1] == my_addr )) begin
-
+			     if (slave_en & slave_adr_received &(slave_adr[7:1] == my_addr )& ~master_mode)
+			     begin
 				c_state  <=  ST_SL_ACK;
 				master_mode <=  1'b0;
 				slave_act <=  1'b1;
 				slave_cmd <=  `I2C_SLAVE_CMD_WRITE;
 				core_txd <=  1'b0;
+			    end
+
 
-			 end
 		 else if (go && !slave_act )
 	            begin
 	                if (start)
@@ -372,7 +375,7 @@
             ST_SL_WAIT: //Wait for interupt-clear and hold SCL in waitstate
               begin
                  sl_wait <=  1'b1;
-                 if (sl_cont) begin
+                 if (sl_cont || slave_act) begin
                     sl_wait <=  1'b0;
                     ld <=  1'b1;
                     slave_dat_req	<=  1'b0;
@@ -397,7 +400,7 @@
 		 if (slave_ack)  begin
                     ack_out <=  core_rxd;
                     slave_cmd_ack  <=  1'b1;
-                    if (!core_rxd) begin // Valid ack recived
+                    //if (!core_rxd) begin // Valid ack recived  //mudar para  !core_rxd
                        // generate slave command acknowledge signal if
 		       // succesful transfer
                        c_state   <=  ST_SL_WAIT;
@@ -407,15 +410,15 @@
 	               else begin              // I2C write request
 	                  slave_dat_avail	<=  1'b1;
 	               end
-	            end
-	            else begin
-	               c_state   <=  ST_IDLE;
-	            end
+	           // end
+	           // else begin
+	            //   c_state   <=  ST_IDLE;
+	           // end  //! (!core_rxd)
 	         end
 	         else begin
 	            core_txd <=  1'b0;
-	         end
-	            end
+	         end //!if (slave_ack)  begin
+	       end
 
 	        ST_START:
 	          if (core_ack)
@@ -439,7 +442,7 @@
 	            if (cnt_done)
 	              begin
 	                  c_state  <= ST_ACK;
-	                  core_cmd <= `I2C_CMD_READ;
+	                  core_cmd <= `I2C_CMD_S_ACK; // I2C_CMD_NOP; //
 	              end
 	            else
 	              begin
@@ -469,28 +472,31 @@
 	        ST_ACK:
 	          if (core_ack)
 	            begin
-	               if (stop)
-	                 begin
-	                     c_state  <= ST_STOP;
-	                     core_cmd <= `I2C_CMD_STOP;
-	                 end
-	               else
-	                 begin
-	                     c_state  <= ST_IDLE;
-	                     core_cmd <= `I2C_CMD_NOP;
-
-	                     // generate command acknowledge signal
-	                     cmd_ack  <= 1'b1;
-	                 end
-
-	                 // assign ack_out output to bit_controller_rxd (contains last received bit)
-	                 ack_out <= core_rxd;
-
-	                 core_txd <= 1'b1;
+			if(receved_ask)
+			begin
+	               	   if (stop)
+	                   begin
+	                      c_state  <= ST_STOP;
+	                      core_cmd <= `I2C_CMD_STOP;
+	                   end
+	                   else
+	                   begin
+	                       c_state  <= ST_IDLE;
+	                       core_cmd <= `I2C_CMD_NOP;
+	                       // generate command acknowledge signal
+	                       cmd_ack  <= 1'b1;
+ 			   end //!if (stop)
+
+	                   // assign ack_out output to bit_controller_rxd (contains last received bit)
+	                   ack_out <= core_rxd;
+	                   //core_txd <= 1'b1;
+			end //!	if(1'b0)
 	             end
 	           else
 	             core_txd <= ack_in;
 
+
+
 	        ST_STOP:
 	          if (core_ack)
 	            begin
diff -Naur i2c/i2c_master_defines.v i2c_escreve/i2c_master_defines.v
--- i2c/i2c_master_defines.v	2013-12-06 19:08:46.848143980 +0000
+++ i2c_escreve/i2c_master_defines.v	2013-12-04 17:57:33.621599183 +0000
@@ -57,7 +57,9 @@
 `define I2C_CMD_STOP  4'b0010
 `define I2C_CMD_WRITE 4'b0100
 `define I2C_CMD_READ  4'b1000
+`define I2C_CMD_S_ACK 4'b1111
 
 `define I2C_SLAVE_CMD_WRITE 2'b01
 `define I2C_SLAVE_CMD_READ 2'b10
 `define I2C_SLAVE_CMD_NOP 2'b00
+
diff -Naur i2c/i2c_master_top.v i2c_escreve/i2c_master_top.v
--- i2c/i2c_master_top.v	2013-12-06 19:08:46.852143929 +0000
+++ i2c_escreve/i2c_master_top.v	2013-12-06 18:05:09.745335747 +0000
@@ -79,11 +79,11 @@
   (
 	wb_clk_i, wb_rst_i, arst_i, wb_adr_i, wb_dat_i, wb_dat_o,
 	wb_we_i, wb_stb_i, wb_cyc_i, wb_ack_o, wb_inta_o,
-	scl_pad_i, scl_pad_o, scl_padoen_o, sda_pad_i, sda_pad_o, sda_padoen_o );
+	scl_pad_i, scl_pad_o, scl_padoen_o, sda_pad_i, sda_pad_o, sda_padoen_o,slave_dat_avail,stop );
 
 	// parameters
     parameter ARST_LVL = 1'b1; // asynchronous reset level
-    parameter [6:0] DEFAULT_SLAVE_ADDR  = 7'b111_1110;
+    parameter [6:0] DEFAULT_SLAVE_ADDR  = 7'hA0;
 	//
 	// inputs & outputs
 	//
@@ -116,6 +116,10 @@
 	output sda_pad_o;       // SDA-line output (always 1'b0)
 	output sda_padoen_o;    // SDA-line output enable (active low)
 
+	// mem
+	output slave_dat_avail;
+	output stop;
+
 
 	//
 	// variable declarations
@@ -128,7 +132,7 @@
 	wire [ 7:0] rxr;  // receive register
 	reg  [ 7:0] cr;   // command register
 	wire [ 7:0] sr;   // status register
-	reg  [ 6:0] sladr;// slave address register
+	reg  [ 6:0] sladr;// slave address registe
 
 	// done signal: command completed, clear command register
 	wire done;
@@ -147,6 +151,7 @@
 	wire i2c_al;      // i2c bus arbitration lost
 	reg  al;          // status register arbitration lost bit
 	reg  slave_mode;
+	reg  status; 	  // if can receved new instruction
 	//
 	// module body
 	//
@@ -160,23 +165,36 @@
 	// generate acknowledge output signal ...
 	always @(posedge wb_clk_i)
     // ... because timing is always honored.
-    wb_ack_o <=  wb_cyc_i & wb_stb_i & ~wb_ack_o;
+    wb_ack_o <=  wb_cyc_i & wb_stb_i & ~wb_ack_o & status;
 
 	// assign DAT_O
 	always @(posedge wb_clk_i)
+	   if (slave_act)
+	   begin
+		if(slave_dat_avail)
+		    wb_dat_o <= rxr;
+	   end
+
+	// assign DAT_O
+/*	always @(posedge wb_clk_i)
 	begin
 	  case (wb_adr_i) // synopsys parallel_case
-	    3'b000: wb_dat_o <= prer[ 7:0];
-	    3'b001: wb_dat_o <= prer[15:8];
-	    3'b010: wb_dat_o <= ctr;
-	    3'b011: wb_dat_o <= rxr; // write is transmit register (txr)
-	    3'b100: wb_dat_o <= sr;  // write is command register (cr)
-	    3'b101: wb_dat_o <= txr; // Debug out of TXR
-	    3'b110: wb_dat_o <= cr;  // Debug out control reg
+	    //3'b000: wb_dat_o <= prer[ 7:0];
+	    //3'b001: wb_dat_o <= prer[15:8];
+	   // 3'b010: wb_dat_o <= ctr;
+	  //  3'b011: wb_dat_o <= rxr; // write is transmit register (txr)
+	    //3'b100:  // recive
+			begin
+			 	wb_dat_o <= rxr;
+			 	cr <= 8'b0010000;
+			end
+
+	    //3'b101: wb_dat_o <= txr; // Debug out of TXR
+	    //3'b110: wb_dat_o <= cr;  // Debug out control reg
 	    3'b111: wb_dat_o <= {1'b0,sladr};   // slave address register
 	  endcase
 	end
-
+*/
 	// generate registers
 	always @(posedge wb_clk_i or negedge rst_i)
 	  if (!rst_i)
@@ -184,25 +202,43 @@
 	        prer <= 16'hffff;
 	        ctr  <=  8'h0;
 	        txr  <=  8'h0;
-	        sladr <=  DEFAULT_SLAVE_ADDR;
+	        sladr <= 7'h50;// DEFAULT_SLAVE_ADDR;
+		status <=1'b1;
 	    end
 	  else if (wb_rst_i)
 	    begin
 	        prer <= 16'hffff;
 	        ctr  <=  8'h0;
 	        txr  <=  8'h0;
-	        sladr <=  DEFAULT_SLAVE_ADDR;
+	        sladr <= 7'h50; // DEFAULT_SLAVE_ADDR;
+		status <=1'b1;
 	    end
 	  else
 	    if (wb_wacc)
+	    begin
+	      status <=1'b0;
 	      case (wb_adr_i) // synopsys parallel_case
-	         3'b000 : prer [ 7:0] <= wb_dat_i;
-	         3'b001 : prer [15:8] <= wb_dat_i;
-	         3'b010 : ctr         <= wb_dat_i;
-	         3'b011 : txr         <= wb_dat_i;
-	         3'b111 : sladr       <=  wb_dat_i[6:0];
+	         3'b000 : //send star and word
+			begin
+			 	prer [ 7:0] <= wb_dat_i;
+			 	cr <= 8'b10010000;
+				txr <= wb_dat_i;
+			end
+	         3'b001 : // send word
+			begin
+			 	txr <= wb_dat_i;
+			 	cr <= 8'b00010000;
+			end
+
+	         3'b010 : //send last word( word + stop)
+			begin
+			 	txr <= wb_dat_i;
+			 	cr <= 8'b01010000;
+			end
+	        // 3'b111 : sladr       <=  wb_dat_i[6:0]; //send slave addr
 	         default: ;
 	      endcase
+	    end
 
 	// generate command register (special case)
 	always @(posedge wb_clk_i or negedge rst_i)
@@ -219,8 +255,10 @@
 	    begin
 	        cr[1] <=  1'b0;
 	        if (done | i2c_al)
+		begin
 	          cr[7:4] <= 4'h0;           // clear command bits when done
-	                                        // or when aribitration lost
+	          status <=1'b1;            // or when aribitration lost
+		end
 	        cr[2] <=  1'b0;             // reserved bits
 	        cr[0]   <= 1'b0;             // clear IRQ_ACK bit
 	    end
@@ -238,7 +276,7 @@
 	// decode control register
 	assign core_en = ctr[7];
 	assign ien = ctr[6];
-	assign slave_en = ctr[5];
+	assign slave_en = 1'b1; //ctr[5];
 
 
 	// hookup byte controller block
@@ -271,7 +309,8 @@
 		.slave_dat_req (slave_dat_req),
 		.slave_dat_avail (slave_dat_avail),
 		.slave_act (slave_act),
-		.slave_cmd_ack (slave_done)
+		.slave_cmd_ack (slave_done),
+		.stop_signal(stop)
 	);
 
 	// status register block + interrupt request signal
diff -Naur i2c/.svn/all-wcprops i2c_escreve/.svn/all-wcprops
--- i2c/.svn/all-wcprops	2013-12-06 19:08:46.748145236 +0000
+++ i2c_escreve/.svn/all-wcprops	2013-11-29 20:30:36.053310756 +0000
@@ -3,6 +3,12 @@
 V 44
 /ocsvn/i2c/!svn/ver/74/i2c/trunk/rtl/verilog
 END
+i2c_master_byte_ctrl.v
+K 25
+svn:wc:ra_dav:version-url
+V 67
+/ocsvn/i2c/!svn/ver/68/i2c/trunk/rtl/verilog/i2c_master_byte_ctrl.v
+END
 i2c_master_defines.v
 K 25
 svn:wc:ra_dav:version-url
@@ -27,9 +33,3 @@
 V 61
 /ocsvn/i2c/!svn/ver/73/i2c/trunk/rtl/verilog/i2c_master_top.v
 END
-i2c_master_byte_ctrl.v
-K 25
-svn:wc:ra_dav:version-url
-V 67
-/ocsvn/i2c/!svn/ver/68/i2c/trunk/rtl/verilog/i2c_master_byte_ctrl.v
-END
diff -Naur i2c/.svn/entries i2c_escreve/.svn/entries
--- i2c/.svn/entries	2013-12-06 19:08:46.748145236 +0000
+++ i2c_escreve/.svn/entries	2013-11-29 20:30:36.053310756 +0000
@@ -32,7 +32,7 @@
 
 
 
-2013-12-06T19:08:46.748145Z
+2013-11-29T20:30:36.041310Z
 b1ff012cc75f27d1e9f26bbd0273e1a2
 2010-01-12T16:36:48.517940Z
 74
@@ -66,7 +66,7 @@
 
 
 
-2013-12-06T19:08:46.748145Z
+2013-11-29T20:30:36.045310Z
 38b9bdc4d5ec1a4ffbaeceacca022939
 2010-01-12T16:35:28.806834Z
 73
@@ -100,7 +100,7 @@
 
 
 
-2013-12-06T19:08:46.748145Z
+2013-11-29T20:30:36.041310Z
 b0b9eb5b628c41b59b96ff195835fb67
 2009-01-19T20:29:26.000000Z
 62
@@ -134,7 +134,7 @@
 
 
 
-2013-12-06T19:08:46.748145Z
+2013-11-29T20:30:36.041310Z
 b220b22dedef9e43dfb5da4e81d7559b
 2001-11-05T11:59:25.000000Z
 14
@@ -168,7 +168,7 @@
 
 
 
-2013-12-06T19:08:46.748145Z
+2013-11-29T20:30:36.041310Z
 37271dfad171745685f638454b851a03
 2001-09-24T12:21:51.000000Z
 10
