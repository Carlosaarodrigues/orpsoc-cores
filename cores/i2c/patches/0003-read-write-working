diff -Naur a/i2c_master_bit_ctrl.v b/i2c_master_bit_ctrl.v
--- a/i2c_master_bit_ctrl.v	2013-12-11 18:32:52.698047462 +0000
+++ b/i2c_master_bit_ctrl.v	2013-12-11 18:41:04.811860756 +0000
@@ -141,35 +141,38 @@
 `include "i2c_master_defines.v"
 
 module i2c_master_bit_ctrl (
-    input             clk,      // system clock
-    input             rst,      // synchronous active high reset
-    input             nReset,   // asynchronous active low reset
-    input             ena,      // core enable signal
-
-    input      [15:0] clk_cnt,  // clock prescale value
-
-    input      [ 3:0] cmd,      // command (from byte controller)
-    output reg        cmd_ack,  // command complete acknowledge
-    output reg        busy,     // i2c bus busy
-    output reg        al,       // i2c bus arbitration lost
-
-    input             din,
-    output reg        dout,
-
-    input             scl_i,    // i2c clock line input
-    output            scl_o,    // i2c clock line output
-    output            scl_oen,  // i2c clock line output enable (active low)
-    input             sda_i,    // i2c data line input
-    output            sda_o,    // i2c data line output
-    output            sda_oen,  // i2c data line output enable (active low)
-
-    output reg        slave_adr_received,
-    output reg [7:0]  slave_adr,
-    input             master_mode,
-    output reg        cmd_slave_ack,
-    input [1:0]       slave_cmd ,
-    input             sl_wait,
-    output            slave_reset
+    input             	clk,      // system clock
+    input             	rst,      // synchronous active high reset
+    input             	nReset,   // asynchronous active low reset
+    input             	ena,      // core enable signal
+
+    input      [15:0] 	clk_cnt,  // clock prescale value
+
+    input      [ 3:0] 	cmd,      // command (from byte controller)
+    output reg        	cmd_ack,  // command complete acknowledge
+    output reg        	busy,     // i2c bus busy
+    output reg        	al,       // i2c bus arbitration lost
+
+    input             	din,
+    output reg        	dout,
+
+    input             	scl_i,    // i2c clock line input
+    output            	scl_o,    // i2c clock line output
+    output            	scl_oen,  // i2c clock line output enable (active low)
+    input             	sda_i,    // i2c data line input
+    output            	sda_o,    // i2c data line output
+    output            	sda_oen,  // i2c data line output enable (active low)
+
+    output reg        	slave_adr_received,
+    output reg [7:0]  	slave_adr,
+    input             	master_mode,
+    output reg        	cmd_slave_ack,
+    input [1:0]       	slave_cmd ,
+    input             	sl_wait,
+    output            	slave_reset,
+    output	      	recev_ack,  //slave ack
+    output	      	sto_condition,  //stop signal
+    output		sta_condition	//start signal
 
 );
 
@@ -280,8 +283,8 @@
       end
       else if (~|filter_cnt)
       begin
-          fSCL <= {fSCL[1:0],cSCL[1]};
-          fSDA <= {fSDA[1:0],cSDA[1]};
+          fSCL <= {fSCL[1:0],scl_i};
+          fSDA <= {fSDA[1:0],sda_i};
       end
 
 
@@ -328,7 +331,7 @@
           sta_condition <= 1'b0;
           sto_condition <= 1'b0;
       end
-      else
+      else if (~master_mode)
       begin
           sta_condition <= ~sSDA &  dSDA & sSCL;
           sto_condition <=  sSDA & ~dSDA & sSCL;
@@ -366,7 +369,7 @@
 
     // generate dout signal (store SDA on rising edge of SCL)
     always @(posedge clk)
-      if (sSCL & ~dSCL) dout <= sSDA;
+     dout <= sSDA;
 
 
     // generate statemachine
@@ -390,6 +393,12 @@
     parameter [17:0] wr_b    = 18'b0_0100_0000_0000_0000;
     parameter [17:0] wr_c    = 18'b0_1000_0000_0000_0000;
     parameter [17:0] wr_d    = 18'b1_0000_0000_0000_0000;
+    parameter [17:0] wr_e    = 18'b1_1000_0000_0000_0000;
+    parameter [17:0] ack_a   = 18'b1_1111_1111_1111_0000;
+    parameter [17:0] ack_b   = 18'b1_1111_1111_1111_0001;
+    parameter [17:0] ack_c   = 18'b1_1111_1111_1111_0010;
+    parameter [17:0] ack_d   = 18'b1_1111_1111_1111_0100;
+
 
     reg scl_oen_master ;
     reg sda_oen_master ;
@@ -404,6 +413,7 @@
           scl_oen_master <=  1'b1;
           sda_oen_master <=  1'b1;
           sda_chk <= 1'b0;
+	  recev_ack <= 1'b0;
       end
       else if (rst | al)
       begin
@@ -412,6 +422,7 @@
           scl_oen_master <=  1'b1;
           sda_oen_master <=  1'b1;
           sda_chk <= 1'b0;
+	  recev_ack <= 1'b0;
       end
       else
       begin
@@ -427,7 +438,8 @@
                              `I2C_CMD_STOP:  c_state <= stop_a;
                              `I2C_CMD_WRITE: c_state <= wr_a;
                              `I2C_CMD_READ:  c_state <= rd_a;
-                             default:        c_state <= idle;
+			     `I2C_CMD_ACK: c_state <= ack_a;
+			     default: 	     c_state <= idle;
                         endcase
 
                         scl_oen_master <= scl_oen_master; // keep SCL in same state
@@ -435,10 +447,49 @@
                         sda_chk <= 1'b0;    // don't check SDA output
                     end
 
+                    ack_a:// wait ack
+                    begin
+                        c_state <= ack_b;
+                        scl_oen_master <= 1'b0; // keep SCL low
+                        sda_oen_master <= 1'b1; // tri-state SDA
+
+                    end
+
+                    ack_b:
+                    begin
+                        c_state <= ack_c;
+			    if(~sda_i )//(~sda_i & ~sSDA)
+			    begin
+				//c_state <= idle;
+				recev_ack <= 1'b1;
+			    end
+                        cmd_ack <= 1'b1;
+                        scl_oen_master <= 1'b1; // set SCL high
+                        sda_oen_master <= 1'b1; // keep SDA tri-stated
+                        sda_chk <= 1'b0; // don't check SDA output
+                    end
+
+                    ack_c:
+                    begin
+                        c_state <= ack_d;
+                        scl_oen_master <= 1'b1; // keep SCL high
+                        sda_oen_master <= 1'b1; // keep SDA tri-stated
+                        sda_chk <= 1'b0; // don't check SDA output
+                    end
+
+                    ack_d:
+                    begin
+                        c_state <= idle;
+                        scl_oen_master <= 1'b0; // set SCL low
+                        sda_oen_master <= 1'b1; // keep SDA tri-stated
+                        sda_chk <= 1'b0; // don't check SDA output
+                    end
+
                     // start
                     start_a:
                     begin
                         c_state <= start_b;
+	  		recev_ack <= 1'b0;
                         scl_oen_master <= scl_oen_master; // keep SCL in same state
                         sda_oen_master <= 1'b1;    // set SDA high
                         sda_chk <= 1'b0;    // don't check SDA output
@@ -455,6 +506,7 @@
                     start_c:
                     begin
                         c_state <= start_d;
+                        cmd_ack <= 1'b1;
                         scl_oen_master <= 1'b1; // keep SCL high
                         sda_oen_master <= 1'b0; // set SDA low
                         sda_chk <= 1'b0; // don't check SDA output
@@ -471,7 +523,6 @@
                     start_e:
                     begin
                         c_state <= idle;
-                        cmd_ack <= 1'b1;
                         scl_oen_master <= 1'b0; // set SCL low
                         sda_oen_master <= 1'b0; // keep SDA low
                         sda_chk <= 1'b0; // don't check SDA output
@@ -481,6 +532,7 @@
                     stop_a:
                     begin
                         c_state <= stop_b;
+	  		recev_ack <= 1'b0;
                         scl_oen_master <= 1'b0; // keep SCL low
                         sda_oen_master <= 1'b0; // set SDA low
                         sda_chk <= 1'b0; // don't check SDA output
@@ -489,6 +541,7 @@
                     stop_b:
                     begin
                         c_state <= stop_c;
+                        cmd_ack <= 1'b1;
                         scl_oen_master <= 1'b1; // set SCL high
                         sda_oen_master <= 1'b0; // keep SDA low
                         sda_chk <= 1'b0; // don't check SDA output
@@ -505,7 +558,6 @@
                     stop_d:
                     begin
                         c_state <= idle;
-                        cmd_ack <= 1'b1;
                         scl_oen_master <= 1'b1; // keep SCL high
                         sda_oen_master <= 1'b1; // set SDA high
                         sda_chk <= 1'b0; // don't check SDA output
@@ -515,6 +567,7 @@
                     rd_a:
                     begin
                         c_state <= rd_b;
+	  		recev_ack <= 1'b0;
                         scl_oen_master <= 1'b0; // keep SCL low
                         sda_oen_master <= 1'b1; // tri-state SDA
                         sda_chk <= 1'b0; // don't check SDA output
@@ -523,6 +576,7 @@
                     rd_b:
                     begin
                         c_state <= rd_c;
+                        cmd_ack <= 1'b1;
                         scl_oen_master <= 1'b1; // set SCL high
                         sda_oen_master <= 1'b1; // keep SDA tri-stated
                         sda_chk <= 1'b0; // don't check SDA output
@@ -539,7 +593,7 @@
                     rd_d:
                     begin
                         c_state <= idle;
-                        cmd_ack <= 1'b1;
+
                         scl_oen_master <= 1'b0; // set SCL low
                         sda_oen_master <= 1'b1; // keep SDA tri-stated
                         sda_chk <= 1'b0; // don't check SDA output
@@ -549,34 +603,44 @@
                     wr_a:
                     begin
                         c_state <= wr_b;
+	  		recev_ack <= 1'b0;
                         scl_oen_master <= 1'b0; // keep SCL low
-                        sda_oen_master <= din;  // set SDA
+                        sda_oen_master <= sda_oen_master;  // set SDA
                         sda_chk <= 1'b0; // don't check SDA output (SCL low)
                     end
 
                     wr_b:
                     begin
                         c_state <= wr_c;
+	  		recev_ack <= 1'b0;
+                        scl_oen_master <= 1'b0; // keep SCL low
+                        sda_oen_master <= din;  // set SDA
+                        sda_chk <= 1'b0; // don't check SDA output (SCL low)
+                    end
+
+                    wr_c:
+                    begin
+                        c_state <= wr_d;
+                        cmd_ack <= 1'b1;
                         scl_oen_master <= 1'b1; // set SCL high
-                        sda_oen_master <= din;  // keep SDA
+                        sda_oen_master <= sda_oen_master;  // keep SDA
                         sda_chk <= 1'b0; // don't check SDA output yet
                                             // allow some time for SDA and SCL to settle
                     end
 
-                    wr_c:
+                    wr_d:
                     begin
-                        c_state <= wr_d;
+                        c_state <= wr_e;
                         scl_oen_master <= 1'b1; // keep SCL high
-                        sda_oen_master <= din;
-                        sda_chk <= 1'b1; // check SDA output
+                        sda_oen_master <= sda_oen_master;
+                        sda_chk <= 1'b0; // check SDA output
                     end
 
-                    wr_d:
+                    wr_e:
                     begin
                         c_state <= idle;
-                        cmd_ack <= 1'b1;
                         scl_oen_master <= 1'b0; // set SCL low
-                        sda_oen_master <= din;
+                        sda_oen_master <= sda_oen_master;
                         sda_chk <= 1'b0; // don't check SDA output (SCL low)
                     end
 
@@ -608,9 +672,10 @@
 	if ((sSCL & ~dSCL) && slave_cnt != 4'h0 && slave_act)	 begin
 	   slave_adr <=  {slave_adr[6:0], sSDA};
 	   slave_cnt <=  slave_cnt -1;
+	   slave_adr_received <=  1'b1;
 	end
 	else if (slave_cnt == 4'h0 && !sta_condition && slave_act) begin
-	   slave_adr_received <=  1'b1;
+
 	   slave_act <=  1'b0;
 	end
 
@@ -641,14 +706,13 @@
        begin
           slave_state <=  slave_idle;
           cmd_slave_ack   <=  1'b0;
-          sda_oen_slave   <=  1'b1;
+          sda_oen_slave   <=  1'b0;
           scl_oen_slave   <=  1'b1;
        end
-     else if (rst | sta_condition || !ena)
+     else if (rst | sta_condition)
        begin
           slave_state <=  slave_idle;
           cmd_slave_ack   <=  1'b0;
-          sda_oen_slave   <=  1'b1;
           scl_oen_slave   <=  1'b1;
        end
      else
@@ -667,7 +731,7 @@
 
                  case (slave_cmd) // synopsys full_case parallel_case
                    `I2C_SLAVE_CMD_WRITE: slave_state <=  slave_wr;
-                   `I2C_SLAVE_CMD_READ:
+                   `I2C_SLAVE_CMD_READ:	
 		     begin
 			slave_state <=  slave_rd;
 			// Restore SDA high here in case we're got it low
@@ -683,18 +747,16 @@
 
             slave_wr:
               begin
-                 if (~sSCL & ~dSCL)  begin //SCL == LOW
+                 sda_oen_slave <=  din;
+                 if (sSCL & ~dSCL) begin
                     slave_state <=  slave_wr_a;
-                    sda_oen_slave <=  din;
                  end
               end
 
             slave_wr_a:
               begin
-                 if (~sSCL & dSCL)  begin //SCL FALLING EDGE
                     cmd_slave_ack <=  1'b1;
                     slave_state <=  slave_wait_next_cmd_1;
-                 end
               end
 
 	    slave_wait_next_cmd_1:
@@ -713,11 +775,12 @@
 
             slave_rd_a:
               begin
-                 if (~sSCL & dSCL)  begin       // SCL falling edge
+                 //if (~sSCL & dSCL)  begin       // SCL falling edge //comenta da para a escrita não comentado não dá para a leitura.
                     cmd_slave_ack <=  1'b1;
                     slave_state <=  slave_wait_next_cmd_1;
-                 end
+                 //end
               end
+
           endcase // case (slave_state)
        end
 
diff -Naur a/i2c_master_byte_ctrl.v b/i2c_master_byte_ctrl.v
--- a/i2c_master_byte_ctrl.v	2013-12-11 18:32:52.710047312 +0000
+++ b/i2c_master_byte_ctrl.v	2013-12-11 18:40:37.968198225 +0000
@@ -77,8 +77,7 @@
    clk, my_addr, rst, nReset, ena, clk_cnt, start, stop, read, write, ack_in,
    din, cmd_ack, ack_out, dout, i2c_busy, i2c_al, scl_i, sl_cont, scl_o,
    scl_oen, sda_i, sda_o, sda_oen,slave_dat_req, slave_en, slave_dat_avail,
-   slave_act, slave_cmd_ack
-   );
+   slave_act, slave_cmd_ack, stop_signal,start_signal);
 
 
 	//
@@ -121,6 +120,8 @@
     output reg 	slave_dat_avail;
     output reg 	slave_act;
     output reg 	slave_cmd_ack;
+    output stop_signal; //stop signal
+    output start_signal; //stop signal
 	//
 	// Variable declarations
 	//
@@ -194,7 +195,10 @@
 		.cmd_slave_ack (slave_ack),
 		.slave_cmd (slave_cmd_out),
 		.sl_wait (sl_wait),
-		.slave_reset (slave_reset)
+		.slave_reset (slave_reset),
+		.recev_ack(receved_ask),
+		.sto_condition(stop_signal),
+		.sta_condition(start_signal)
 	);
 
 	reg 		slave_adr_received_d;
@@ -221,7 +225,7 @@
 	  else if (shift)
 	    sr <= {sr[6:0], core_rxd};
       else if (slave_adr_received_d & slave_act)
-        sr <=  {slave_adr[7:1], 1'b0};
+        sr <= slave_adr; 
 
 
 
@@ -231,6 +235,8 @@
 	    dcnt <= 3'h0;
 	  else if (rst)
 	    dcnt <= 3'h0;
+	  else if (ld && slave_adr[0] && !master_mode)
+	    dcnt <= 3'h6;
 	  else if (ld)
 	    dcnt <= 3'h7;
 	  else if (shift)
@@ -274,7 +280,6 @@
 	       cmd_ack  <= 1'b0;
 	       c_state  <= ST_IDLE;
 	       ack_out  <= 1'b0;
-	       master_mode <=  1'b0;
 	       slave_cmd  <=  2'b0;
 	       slave_cmd_out <=  2'b0;
 	       slave_dat_req	<=  1'b0;
@@ -296,16 +301,16 @@
 	        ST_IDLE:
 			  begin
 			     slave_act <=  1'b0;
-			     if (slave_en & slave_adr_received &
-				 (slave_adr[7:1] == my_addr )) begin
-
+			     if (slave_en & slave_adr_received &(slave_adr[7:1] == my_addr )& ~master_mode)
+			     begin
 				c_state  <=  ST_SL_ACK;
 				master_mode <=  1'b0;
 				slave_act <=  1'b1;
 				slave_cmd <=  `I2C_SLAVE_CMD_WRITE;
 				core_txd <=  1'b0;
+			    end
+
 
-			 end
 		 else if (go && !slave_act )
 	            begin
 	                if (start)
@@ -369,27 +374,6 @@
 	              shift    <=  1'b1;
 	           end
 	      end
-            ST_SL_WAIT: //Wait for interupt-clear and hold SCL in waitstate
-              begin
-                 sl_wait <=  1'b1;
-                 if (sl_cont) begin
-                    sl_wait <=  1'b0;
-                    ld <=  1'b1;
-                    slave_dat_req	<=  1'b0;
-                    slave_dat_avail	<=  1'b0;
-                    c_state   <=  ST_SL_PRELOAD;
-	         end
-              end
-
-            ST_SL_PRELOAD:
-              if (slave_adr[0]) begin
-	         c_state   <=  ST_SL_RD;
-	         slave_cmd <=  `I2C_SLAVE_CMD_WRITE;
-	      end
-	      else begin
-	         c_state  <=  ST_SL_WR;
-	         slave_cmd <=  `I2C_SLAVE_CMD_READ;
-	      end
 
             ST_SL_ACK:
               begin
@@ -397,7 +381,7 @@
 		 if (slave_ack)  begin
                     ack_out <=  core_rxd;
                     slave_cmd_ack  <=  1'b1;
-                    if (!core_rxd) begin // Valid ack recived
+                    if (!sda_i || !slave_adr[0]) begin // Valid ack recived
                        // generate slave command acknowledge signal if
 		       // succesful transfer
                        c_state   <=  ST_SL_WAIT;
@@ -417,6 +401,28 @@
 	         end
 	            end
 
+            ST_SL_WAIT: //Wait for interupt-clear and hold SCL in waitstate
+              begin
+                 sl_wait <=  1'b1;
+                 if (sl_cont || slave_act) begin
+                    sl_wait <=  1'b0;
+                    ld <=  1'b1;
+                    slave_dat_req	<=  1'b0;
+                    slave_dat_avail	<=  1'b0;
+                    c_state   <=  ST_SL_PRELOAD;
+	         end
+              end
+
+            ST_SL_PRELOAD:
+              if (slave_adr[0]) begin
+	         c_state   <=  ST_SL_RD;
+	         slave_cmd <=  `I2C_SLAVE_CMD_WRITE;
+	      end
+	      else begin
+	         c_state  <=  ST_SL_WR;
+	         slave_cmd <=  `I2C_SLAVE_CMD_READ;
+	      end
+
 	        ST_START:
 	          if (core_ack)
 	            begin
@@ -439,7 +445,7 @@
 	            if (cnt_done)
 	              begin
 	                  c_state  <= ST_ACK;
-	                  core_cmd <= `I2C_CMD_READ;
+	                  core_cmd <= `I2C_CMD_ACK;
 	              end
 	            else
 	              begin
@@ -469,28 +475,30 @@
 	        ST_ACK:
 	          if (core_ack)
 	            begin
-	               if (stop)
-	                 begin
-	                     c_state  <= ST_STOP;
-	                     core_cmd <= `I2C_CMD_STOP;
-	                 end
-	               else
-	                 begin
-	                     c_state  <= ST_IDLE;
-	                     core_cmd <= `I2C_CMD_NOP;
-
-	                     // generate command acknowledge signal
-	                     cmd_ack  <= 1'b1;
-	                 end
-
-	                 // assign ack_out output to bit_controller_rxd (contains last received bit)
-	                 ack_out <= core_rxd;
-
-	                 core_txd <= 1'b1;
+			if(receved_ask | read)
+			begin
+	               	   if (stop)
+	                   begin
+	                      c_state  <= ST_STOP;
+	                      core_cmd <= `I2C_CMD_STOP;
+	                   end
+	                   else
+	                   begin
+	                       c_state  <= ST_IDLE;
+	                       core_cmd <= `I2C_CMD_NOP;
+	                       // generate command acknowledge signal
+	                       cmd_ack  <= 1'b1;
+ 			   end //!if (stop)
+
+	                   // assign ack_out output to bit_controller_rxd (contains last received bit)
+	                   ack_out <= core_rxd;
+			end //!	if(1'b0)
 	             end
 	           else
 	             core_txd <= ack_in;
 
+
+
 	        ST_STOP:
 	          if (core_ack)
 	            begin
diff -Naur a/i2c_master_defines.v b/i2c_master_defines.v
--- a/i2c_master_defines.v	2013-12-11 18:32:52.714047262 +0000
+++ b/i2c_master_defines.v	2013-12-11 18:40:54.983984309 +0000
@@ -57,7 +57,9 @@
 `define I2C_CMD_STOP  4'b0010
 `define I2C_CMD_WRITE 4'b0100
 `define I2C_CMD_READ  4'b1000
+`define I2C_CMD_ACK 4'b1111
 
 `define I2C_SLAVE_CMD_WRITE 2'b01
 `define I2C_SLAVE_CMD_READ 2'b10
 `define I2C_SLAVE_CMD_NOP 2'b00
+
diff -Naur a/i2c_master_top.v b/i2c_master_top.v
--- a/i2c_master_top.v	2013-12-11 18:32:52.718047212 +0000
+++ b/i2c_master_top.v	2013-12-11 17:32:07.707871196 +0000
@@ -79,11 +79,11 @@
   (
 	wb_clk_i, wb_rst_i, arst_i, wb_adr_i, wb_dat_i, wb_dat_o,
 	wb_we_i, wb_stb_i, wb_cyc_i, wb_ack_o, wb_inta_o,
-	scl_pad_i, scl_pad_o, scl_padoen_o, sda_pad_i, sda_pad_o, sda_padoen_o );
+	scl_pad_i, scl_pad_o, scl_padoen_o, sda_pad_i, sda_pad_o, sda_padoen_o,slave_dat_avail,slave_dat_req,stop,start );
 
 	// parameters
     parameter ARST_LVL = 1'b1; // asynchronous reset level
-    parameter [6:0] DEFAULT_SLAVE_ADDR  = 7'b111_1110;
+    parameter [6:0] DEFAULT_SLAVE_ADDR  = 7'hA0;
 	//
 	// inputs & outputs
 	//
@@ -116,6 +116,12 @@
 	output sda_pad_o;       // SDA-line output (always 1'b0)
 	output sda_padoen_o;    // SDA-line output enable (active low)
 
+	// mem
+	output slave_dat_avail;
+	output slave_dat_req;
+	output stop;
+	output start;
+
 
 	//
 	// variable declarations
@@ -128,7 +134,7 @@
 	wire [ 7:0] rxr;  // receive register
 	reg  [ 7:0] cr;   // command register
 	wire [ 7:0] sr;   // status register
-	reg  [ 6:0] sladr;// slave address register
+	reg  [ 6:0] sladr;// slave address registe
 
 	// done signal: command completed, clear command register
 	wire done;
@@ -147,6 +153,7 @@
 	wire i2c_al;      // i2c bus arbitration lost
 	reg  al;          // status register arbitration lost bit
 	reg  slave_mode;
+	reg  status; 	  // if can receved new instruction
 	//
 	// module body
 	//
@@ -160,20 +167,30 @@
 	// generate acknowledge output signal ...
 	always @(posedge wb_clk_i)
     // ... because timing is always honored.
-    wb_ack_o <=  wb_cyc_i & wb_stb_i & ~wb_ack_o;
+    wb_ack_o <=  wb_cyc_i & wb_stb_i & ~wb_ack_o & status;
+
+	// assign DAT_O
+	always @(posedge wb_clk_i)
+	   if (slave_act)
+	   begin
+		if(slave_dat_avail)
+		    wb_dat_o <= rxr;
+	   end
 
 	// assign DAT_O
 	always @(posedge wb_clk_i)
 	begin
 	  case (wb_adr_i) // synopsys parallel_case
-	    3'b000: wb_dat_o <= prer[ 7:0];
-	    3'b001: wb_dat_o <= prer[15:8];
-	    3'b010: wb_dat_o <= ctr;
-	    3'b011: wb_dat_o <= rxr; // write is transmit register (txr)
-	    3'b100: wb_dat_o <= sr;  // write is command register (cr)
-	    3'b101: wb_dat_o <= txr; // Debug out of TXR
-	    3'b110: wb_dat_o <= cr;  // Debug out control reg
-	    3'b111: wb_dat_o <= {1'b0,sladr};   // slave address register
+
+	         3'b011 : //read
+			begin
+				wb_dat_o <= rxr;
+			end
+	         3'b100 : //read last word (read + Nack + stop)
+			begin
+				wb_dat_o <= rxr;
+			end
+
 	  endcase
 	end
 
@@ -184,25 +201,52 @@
 	        prer <= 16'hffff;
 	        ctr  <=  8'h0;
 	        txr  <=  8'h0;
-	        sladr <=  DEFAULT_SLAVE_ADDR;
+	        sladr <= 7'h50;
+		status <=1'b1;
 	    end
 	  else if (wb_rst_i)
 	    begin
 	        prer <= 16'hffff;
 	        ctr  <=  8'h0;
 	        txr  <=  8'h0;
-	        sladr <=  DEFAULT_SLAVE_ADDR;
+	        sladr <= 7'h50; 
+		status <=1'b1;
 	    end
 	  else
 	    if (wb_wacc)
+	    begin
+	      status <=1'b0;
 	      case (wb_adr_i) // synopsys parallel_case
-	         3'b000 : prer [ 7:0] <= wb_dat_i;
-	         3'b001 : prer [15:8] <= wb_dat_i;
-	         3'b010 : ctr         <= wb_dat_i;
-	         3'b011 : txr         <= wb_dat_i;
-	         3'b111 : sladr       <=  wb_dat_i[6:0];
+	         3'b000 : //send star and word
+			begin
+			 	//prer [ 7:0] <= wb_dat_i;
+			 	cr <= 8'b10010000;
+				txr <= wb_dat_i;
+			end
+	         3'b001 : // write
+			begin
+			 	txr <= wb_dat_i;
+			 	cr <= 8'b00010000;
+			end
+
+	         3'b010 : //write last word( word + stop)
+			begin
+			 	txr <= wb_dat_i;
+			 	cr <= 8'b01010000;
+			end
+
+	         3'b011 : //read
+			begin
+			 	cr <= 8'b00100000;
+			end
+	         3'b100 : //read last word (read + Nack + stop)
+			begin
+			 	cr <= 8'b01101000;
+			end
+
 	         default: ;
 	      endcase
+	    end
 
 	// generate command register (special case)
 	always @(posedge wb_clk_i or negedge rst_i)
@@ -219,8 +263,10 @@
 	    begin
 	        cr[1] <=  1'b0;
 	        if (done | i2c_al)
+		begin
 	          cr[7:4] <= 4'h0;           // clear command bits when done
-	                                        // or when aribitration lost
+	          status <=1'b1;            // or when aribitration lost
+		end
 	        cr[2] <=  1'b0;             // reserved bits
 	        cr[0]   <= 1'b0;             // clear IRQ_ACK bit
 	    end
@@ -238,7 +284,7 @@
 	// decode control register
 	assign core_en = ctr[7];
 	assign ien = ctr[6];
-	assign slave_en = ctr[5];
+	assign slave_en = 1'b1;
 
 
 	// hookup byte controller block
@@ -271,7 +317,9 @@
 		.slave_dat_req (slave_dat_req),
 		.slave_dat_avail (slave_dat_avail),
 		.slave_act (slave_act),
-		.slave_cmd_ack (slave_done)
+		.slave_cmd_ack (slave_done),
+		.stop_signal(stop),
+		.start_signal(start)
 	);
 
 	// status register block + interrupt request signal
